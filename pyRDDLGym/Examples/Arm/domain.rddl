//////////////////////////////////////////////////////////////
//
// TAMP Continuous Finite bi-dimensional Domain fo IPC 2023
//
//
// Task And Motion Planning Problem, where integer data has been included to define the specific coordinates of the cans on the shelfs, which now is finite and bidimensioanal
// Developed by Yuqian Yang, Yoonchang Sung and Fernando Fernandez, 
///////////////////////////////////////////////////////////////


domain can_storage {

  types {
    shelf : object;
    can : object;
     };

  pvariables {

  // Nonfluents: probability constants; int values chosen over real to permit nominalization of integer values for classical planners
    MIN_X(shelf)  	     : { non-fluent, real, default = 0 };
    MIN_Y(shelf) 	     : { non-fluent, real, default = 0 };
    MAX_X(shelf)  	     : { non-fluent, real, default = 10 };
    MAX_Y(shelf) 	     : { non-fluent, real, default = 10 };
    SIZE_X_a	           : { non-fluent, real, default = 1 };
    SIZE_X_c(can)	     : { non-fluent, real, default = 1 };
    SIZE_Y_c(can)	     : { non-fluent, real, default = 1 };
    EPSILON            : {non-fluent, real, default = 1 };

    on-shelf(can,shelf)        : { state-fluent, bool, default = false };
    holding(can)               : { state-fluent, bool, default = false }; 
    arm-free                   : { state-fluent, bool, default = false };
    working-shelf(shelf)       : { state-fluent, bool, default = false };  
    x_position_a               : { state-fluent, real, default = 0 };
    y_position_a               : { state-fluent, real, default = 0 }; //assume is the left most coordinate
    x_position_c(can)          : { state-fluent, real, default = 0 };
    y_position_c(can)          : { state-fluent, real, default = 0 };
    safe-position              : { state-fluent, bool, default = false};

  // Intermediate fluents
    break-extension(can, shelf)         : { interm-fluent, bool}; // returns whether can avoids extension of arm in shelf of the given real size
    break-right-shift(can, shelf)       : { interm-fluent, bool };  // returns whether can avoids right a shift of arm in shelf of the given real size
    break-left-shift(can, shelf)        : {interm-fluent, bool}; // returns whether the can avoids a left shift of the arm in shelf of the given real size 
    put-down-conditions(can,shelf)      : {interm-fluent, bool};
    pick-up-conditions(can, shelf)      : {interm-fluent, bool};
    different-can(can, can)             : {interm-fluent, bool}; //returns true if both cans are the same

    number-of-cans(shelf)               : {interm-fluent, int}; //returns number of cans in the shelf
    objective-shelf(shelf)              : {interm-fluent, bool}; //returns whether the shelf is the one containing more cans
    distance(can)                       : {interm-fluent, real}; //returns the distance from the arm to the can
    closest(can)                        : {interm-fluent, bool}; //returns true if the can is the closest one to the arm
    move-to-can(can)                    : {interm-fluent, bool}; //returns true if the arm is moving towards the closest can

  // Actions 
    extend-arm                 : { action-fluent, real, default = 0 }; //
    retract-arm                : { action-fluent, real, default = 0 };
    retract-off-shelf          : { action-fluent, bool, default = false };
    right-shift                : { action-fluent, real, default = 0 };
    left-shift	               : { action-fluent, real, default = 0 };
    extend-to-shelf            : { action-fluent, bool, default = false };
    pick-up(can,shelf)         : { action-fluent, bool, default = false };
    put-down(can,shelf)        : { action-fluent, bool, default = false };
    change-shelf(shelf,shelf)  : { action-fluent, bool, default = false };
  };

  cpfs {

    number-of-cans(?s) = sum_{?c: can}(on-shelf(?c, ?s));

    objective-shelf(?s) = forall_{?s1: shelf}(number-of-cans(?s) >= number-of-cans(?s1));

    different-can(?c1, ?c2) = if(~(x_position_c(?c1)==x_position_c(?c2) ^ y_position_c(?c1)==y_position_c(?c2))) then true
                              else false;

    distance(?c) = if(exists_{?s: shelf} (on-shelf(?c,?s) ^ working-shelf(?s))) then 
                        sqrt[pow[x_position_a - x_position_c(?c),2] + pow[y_position_a - y_position_c(?c),2]]
                       else 10000.0;

    closest(?c) = forall_{?c1: can}(distance(?c) <= distance(?c1));

    move-to-can(?c) =    (
                          ~safe-position^(sqrt[pow[x_position_a + right-shift - left-shift - x_position_c(?c),2] + 
                          pow[y_position_a + extend-arm - retract-arm - y_position_c(?c),2]] < distance(?c))
                          |
                          safe-position^(sqrt[pow[x_position_a + right-shift - left-shift - x_position_c(?c),2] + 
                          pow[y_position_a + 5*extend-to-shelf - y_position_c(?c),2]] < distance(?c))
                          );

    break-right-shift(?c, ?s) = if(~(holding(?c))^working-shelf(?s)^on-shelf(?c, ?s)^(x_position_c(?c)>x_position_a)) then //basic
                                  if( //arm crash
                                    (
                                      ( (x_position_a + SIZE_X_a + right-shift)>x_position_c(?c) )^
                                      ( y_position_a>y_position_c(?c) )
                                    )
                                    |
                                    (
                                      [exists_{?c1:can}( //can crash
                                        holding(?c1)^
                                        ( (x_position_c(?c1)+SIZE_X_c(?c1)+ right-shift)>=x_position_c(?c) )^
                                        ( 
                                          ( (( y_position_c(?c1)+SIZE_Y_c(?c1))>y_position_c(?c))^
                                            (( y_position_c(?c1)+SIZE_Y_c(?c1))<=( y_position_c(?c)+SIZE_Y_c(?c))))
                                          |
                                          ( (y_position_c(?c1)<( y_position_c(?c)+SIZE_Y_c(?c)))^
                                            (y_position_c(?c1)>y_position_c(?c)) ) 
                                        )
                                      )]
                                    )
                                  ) then true
                                  else false
                                else false;


    break-left-shift(?c, ?s) = if(~(holding(?c))^working-shelf(?s)^on-shelf(?c, ?s)^(x_position_c(?c)<x_position_a)) then //basic
                                  if( //arm crash
                                    (
                                      ( (x_position_a - left-shift)<(x_position_c(?c)+SIZE_X_c(?c)) )^
                                      ( y_position_a>=y_position_c(?c) )
                                    )
                                    |
                                    (
                                      [exists_{?c1:can}( //can crash
                                        holding(?c1)^
                                        ( (x_position_c(?c1) - left-shift)>=(x_position_c(?c)+SIZE_X_c(?c)) )^
                                        ( 
                                          ( (( y_position_c(?c1)+SIZE_Y_c(?c1))>y_position_c(?c))^
                                            (( y_position_c(?c1)+SIZE_Y_c(?c1))<=( y_position_c(?c)+SIZE_Y_c(?c))))
                                          |
                                          ( (y_position_c(?c1)<( y_position_c(?c)+SIZE_Y_c(?c)))^
                                            (y_position_c(?c1)>y_position_c(?c)) ) 
                                        )
                                      )]
                                    )
                                  ) then true
                                  else false
                                else false;
                                                   

    break-extension(?c, ?s) = if (~holding(?c)^working-shelf(?s)^~safe-position^on-shelf(?c,?s)) then
                                if(
                                  ( ( (y_position_a + extend-arm)>y_position_c(?c) )^ //check y
                                    ( 
                                      (
                                        ( (x_position_a + SIZE_X_a)> x_position_c(?c))^
                                        ( (x_position_a + SIZE_X_a)< (x_position_c(?c) + SIZE_X_c(?c)) )
                                      )
                                      |
                                      (
                                        ( x_position_a> x_position_c(?c))^
                                        ( x_position_a< (x_position_c(?c) + SIZE_X_c(?c)) )
                                      )
                                    ) //check x
                                  ) //if the arm breaks-extension
                                  |
                                  (
                                    [exists_{?c1:can}(
                                      holding(?c1)^
                                      ( ( (y_position_c(?c1) + SIZE_Y_c(?c1) + extend-arm)>y_position_c(?c) )^ //check y
                                        ( 
                                          (
                                            ( (x_position_c(?c1) + SIZE_X_c(?c1))> x_position_c(?c))^
                                            ( (x_position_c(?c1) + SIZE_X_c(?c1))< (x_position_c(?c) + SIZE_X_c(?c)) )
                                          )
                                          |
                                          (
                                            ( x_position_c(?c1)> x_position_c(?c))^
                                            ( x_position_c(?c1)< (x_position_c(?c) + SIZE_X_c(?c)) )
                                          )
                                        ) //check x
                                      )
                                    )]
                                  )
                                ) then true
                                else false
                              else false;

    put-down-conditions(?c,?s) = 
      if (holding(?c) ^ working-shelf(?s) ^~safe-position)
        then true
      else false;

    pick-up-conditions(?c, ?s) = 
    if (arm-free ^ working-shelf(?s) ^ on-shelf(?c, ?s) ^ ~safe-position) then
        if (
            ((x_position_a < x_position_c(?c)) ^ ((x_position_a + SIZE_X_a) > x_position_c(?c)))
            | ((x_position_a >= x_position_c(?c)) ^ (x_position_a < (x_position_c(?c) + SIZE_X_c(?c))))
        ) then
            if (
                ((y_position_c(?c) - y_position_a) < EPSILON)
                ^ (~[exists_{?c1:can} (
                    different-can(?c, ?c1) ^
                    (
                        ((y_position_c(?c1) + SIZE_Y_c(?c1)) < y_position_c(?c))
                        ^ ((y_position_c(?c1) + SIZE_Y_c(?c1)) > (y_position_a))
                    ) ^
                    (
                        (
                            (x_position_c(?c1) > x_position_c(?c)) ^ (x_position_c(?c1) < x_position_c(?c) + SIZE_X_c(?c))
                        )
                        | (
                            (x_position_c(?c1) < x_position_c(?c)) ^ (x_position_c(?c1) + SIZE_X_c(?c1) > x_position_c(?c))
                        )
                    )
                )])
            ) then true
            else false
        else false
    else false;

    holding'(?c) = 
        if ([exists_{?s:shelf}(pick-up-conditions(?c,?s)^pick-up(?c, ?s))])
          then true
        else if ([exists_{?s:shelf}(put-down-conditions(?c,?s)^put-down(?c,?s))])
          then false
        else holding(?c);

    arm-free' = 
      if ([exists_{?c: can, ?s:shelf} (pick-up-conditions(?c,?s)^pick-up(?c, ?s))])
        then false
      else if ([exists_{?c:can, ?s:shelf}(put-down-conditions(?c,?s)^put-down(?c,?s))])
        then true
      else arm-free;

    safe-position' = 
      if (retract-off-shelf)
    		then true
			else if (extend-to-shelf)
				then false
			else safe-position;

    working-shelf'(?s2) =
      if ([exists_{?s1: shelf} (working-shelf(?s1) ^ change-shelf(?s1,?s2)^safe-position)])
        then true
      else if ([exists_{?s1: shelf} (working-shelf(?s2) ^ change-shelf(?s2,?s1)^safe-position)])
        then false
      else working-shelf(?s2);
    
    on-shelf'(?c, ?s) = 
      if (put-down-conditions(?c,?s)^put-down(?c,?s))
        then true
      else if (pick-up-conditions(?c,?s)^pick-up(?c, ?s))
        then false
      else on-shelf(?c, ?s);


    x_position_a' = if([exists_{?c:can, ?s:shelf}(break-right-shift(?c,?s)|break-left-shift(?c,?s))]) 
                      then x_position_a
                    else
                      if (
                          [exists_{?s:shelf}(
                            working-shelf(?s)^
                            ( (x_position_a - left-shift)<MIN_X(?s) 
                            | (x_position_a + SIZE_X_a + right-shift)>MAX_X(?s) )
                            |
                            ([exists_{?c:can}(holding(?c)^( (x_position_c(?c) - left-shift)<MIN_X(?s) 
                            | (x_position_c(?c) + SIZE_X_c(?c) + right-shift)>MAX_X(?s) ))])
                          )]
                      ) then x_position_a
                      else
                        x_position_a + right-shift - left-shift;


    y_position_a' = if(retract-off-shelf) then -5 //if not safe position
                    else if (extend-to-shelf) 
                      then if(safe-position) then 0 //if extend from safe-position -> y=0
                           else y_position_a
                    else if ([exists_{?c:can, ?s:shelf}(break-extension(?c, ?s))]) //check break-extension
                      then y_position_a
                    else if ((y_position_a - retract-arm)<0) //check negative retract ->not possible
                      then y_position_a
                    else if ([exists_{?c:can,?s:shelf}(holding(?c)^~safe-position^working-shelf(?s)^
                            (y_position_a + SIZE_Y_c(?c) + extend-arm)>MAX_Y(?s))]) //check limit when holding can
                              then y_position_a
                    else if ([exists_{?s:shelf}(~safe-position^working-shelf(?s)^
                            (y_position_a + extend-arm)>MAX_Y(?s))]) //check limit when not holding can
                              then y_position_a
                    else if (safe-position) then y_position_a
                    else y_position_a + extend-arm - retract-arm;

    x_position_c'(?c) = if(holding'(?c)^~(x_position_a==x_position_a')) then x_position_c(?c) + right-shift - left-shift else x_position_c(?c);
    y_position_c'(?c) = if(holding'(?c)) then y_position_a' else y_position_c(?c);
    };

  reward = 100*([exists_{?s:shelf}([forall_{?c:can}(on-shelf'(?c,?s))])]) + 
           50*([exists_{?s: shelf, ?c:can}(working-shelf(?s)^objective-shelf(?s)^put-down-conditions(?c,?s)^put-down(?c,?s))]) +
           -50*([exists_{?s: shelf, ?c:can}(working-shelf(?s)^objective-shelf(?s)^pick-up-conditions(?c,?s)^pick-up(?c, ?s))]) +
           20*([exists_{?s: shelf, ?c:can}(working-shelf(?s)^~objective-shelf(?s)^pick-up-conditions(?c,?s)^pick-up(?c, ?s))]) +
           -20*([exists_{?s: shelf, ?c:can}(working-shelf(?s)^~objective-shelf(?s)^put-down-conditions(?c,?s)^put-down(?c,?s))]) +
           2.5*(~arm-free ^ safe-position ^ exists_{?s: shelf, ?s1: shelf} (working-shelf(?s)^change-shelf(?s, ?s1)^objective-shelf(?s1))) +
           -2.5*(~arm-free ^ safe-position ^ exists_{?s: shelf, ?s1: shelf} (working-shelf(?s)^change-shelf(?s, ?s1)^~objective-shelf(?s1))) +
           5*(sum_{?c:can}(
              if(arm-free^closest(?c)) then 
                if(move-to-can(?c)) then 1/pow[distance(?c),2]
                else -1.0
              else 0.0
            ))+
            10*([exists_{?s:shelf}(~arm-free^working-shelf(?s)^~objective-shelf(?s)^retract-off-shelf)])+
          
           -100*([exists_{?s: shelf}(change-shelf(?s, ?s))])+
           -100*([exists_{?s: shelf, ?s1:shelf}(change-shelf(?s, ?s1)^~working-shelf(?s))])+
           -100*([exists_{?s: shelf, ?c:can}(working-shelf(?s)^~on-shelf(?c, ?s)^pick-up(?c, ?s))])+
           -100*([exists_{?s: shelf, ?s1:shelf, ?c:can}(working-shelf(?s)^put-down(?c, ?s1)^~working-shelf(?s1))])+
           -100*([exists_{?c: can, ?s:shelf}(pick-up(?c, ?s)^~pick-up-conditions(?c, ?s))])+
           -100*([exists_{?c: can, ?s:shelf}(put-down(?c, ?s)^~put-down-conditions(?c, ?s))])+
           -100*(safe-position^retract-off-shelf)+
           -100*(~safe-position^extend-to-shelf)+
           -100*(safe-position^(retract-arm>0|extend-arm>0))+
           -100*(exists_{?s: shelf, ?s1: shelf}(arm-free^change-shelf(?s, ?s1)^objective-shelf(?s1)))+

           -10*exists_{?c:can, ?s:shelf, ?s1:shelf}((extend-arm>0 | retract-arm>0 | right-shift>0 | left-shift>0 | 
            change-shelf(?s, ?s1) | pick-up(?c, ?s) | put-down(?c, ?s) | retract-off-shelf | extend-to-shelf));

  termination{
      [exists_{?s:shelf}([forall_{?c:can}(on-shelf(?c,?s))])];
  };
  }


